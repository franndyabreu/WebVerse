{"version":3,"sources":["tests/metric-test.js"],"names":["test","require","proxyquire","sinon","metricFixtures","singleMetric","Object","assign","single","type","uuidArgs","uuid","responseUuid","findByAgentUuid","sandbox","db","AgentStub","hasMany","spy","findByAgentUuidArgs","attributes","group","include","model","where","raw","typeAgentUuidArgs","limit","order","config","logging","MetricStub","beforeEach","createSandbox","belongsTo","findAll","stub","findByTypeAgentUuid","withArgs","returns","Promise","resolve","all","setupDB","afterEach","restore","t","truthy","Metric","serial","metric","deepEqual"],"mappings":"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","sourceRoot":"/Users/franndyabreu/Desktop/Platzi-Verse/platziverse-db","sourcesContent":["\"use strict\";\n\nconst test = require(\"ava\");\nconst proxyquire = require(\"proxyquire\");\nconst sinon = require(\"sinon\");\nconst metricFixtures = require(\"./fixtures/metric\");\nconst singleMetric = Object.assign({}, metricFixtures.single);\nconst type = \"cpu\";\nlet uuidArgs = singleMetric.uuid;\n\nconst responseUuid = metricFixtures.findByAgentUuid(metricFixtures.single.uuid);\n\nlet sandbox = null;\nlet db = null;\n\nlet AgentStub = {\n  hasMany: sinon.spy()\n};\n\nconst findByAgentUuidArgs = {\n  attributes: [\"type\"],\n  group: [\"type\"],\n  include: [\n    {\n      attributes: [],\n      model: AgentStub,\n      where: {\n        uuid: uuidArgs\n      }\n    }\n  ],\n  raw: true\n};\n\nconst typeAgentUuidArgs = {\n  attributes: [\"id\", \"type\", \"value\", \"createdAt\"],\n  where: {\n    type\n  },\n  limit: 20,\n  order: [[\"createdAt\", \"DESC\"]],\n  include: [\n    {\n      attributes: [],\n      model: AgentStub,\n      where: {\n        uuid: uuidArgs\n      }\n    }\n  ],\n  raw: true\n};\n\nlet config = {\n  logging: function() {}\n};\n\nlet MetricStub = null;\n\n// const newMetric = {\n//   id: 1,\n//   type: \"memory\",\n//   value: \"705\",\n//   uuid: \"xxx\",\n//   createdAt: new Date(),\n//   updatedAt: new Date()\n// };\n\ntest.beforeEach(async () => {\n  sandbox = sinon.createSandbox();\n  MetricStub = {\n    belongsTo: sinon.spy(),\n    findAll: sinon.stub()\n  };\n\n  //Model findByTypeAgentUuid\n  MetricStub.findByTypeAgentUuid = sandbox.stub();\n  MetricStub.findByTypeAgentUuid\n    .withArgs(typeAgentUuidArgs)\n    .returns(Promise.resolve(metricFixtures.findByTypeAgentUuid(uuidArgs)));\n\n  //Modell findByAgentUuid stub\n  MetricStub.findByAgentUuid = sandbox.stub();\n  MetricStub.findByAgentUuid\n    .withArgs(findByAgentUuidArgs)\n    .returns(Promise.resolve(metricFixtures.findByAgentUuid(uuidArgs)));\n\n  // Model findAll Stub\n  MetricStub.findAll = sandbox.stub();\n  MetricStub.findAll.withArgs().returns(Promise.resolve(metricFixtures.all));\n  MetricStub.findAll\n    .withArgs(findByAgentUuidArgs)\n    .returns(Promise.resolve(responseUuid));\n\n  const setupDB = proxyquire(\"../\", {\n    \"./models/agent\": () => AgentStub,\n    \"./models/metric\": () => MetricStub\n  });\n  db = await setupDB(config);\n});\n\ntest.afterEach(() => {\n  sinon.restore();\n});\n\ntest(\"Metric\", t => {\n  t.truthy(db.Metric, \"Metric service should exist\");\n});\ntest.serial(\"Metric#findByUuid\", async t => {\n  let metric = await db.Metric.findByAgentUuid(uuidArgs);\n\n  t.deepEqual(\n    metric,\n    metricFixtures.findByAgentUuid(uuidArgs),\n    \"Should be the same.\"\n  );\n  //   t.true(MetricStub.findByAgentUuid.called, \"FindByAgentUuid should be called\");\n});\n\ntest.serial(\"Metric#FindByTypeAgentUuid\", async t => {\n  let metric = await db.Metric.findByTypeAgentUuid(typeAgentUuidArgs);\n  t.deepEqual(metric, metricFixtures.findByTypeAgentUuid(type, uuidArgs));\n});\n"]}