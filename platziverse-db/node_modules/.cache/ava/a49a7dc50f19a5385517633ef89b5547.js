"use strict";

const test = require("ava");

const proxyquire = require("proxyquire");

const sinon = require("sinon");

const metricFixtures = require("./fixtures/metric");

let sandbox = null;
let db = null;
let uuidArgs = "xxx";
const singleMetric = Object.assign({}, metricFixtures.single);
let AgentStub = {
  hasMany: sinon.spy()
};
const findByAgentUuidArgs = {
  attributes: ["type"],
  group: ["type"],
  include: [{
    attributes: [],
    model: AgentStub,
    where: {
      uuid: singleMetric.uuid
    }
  }],
  raw: true
};
let config = {
  logging: function () {}
};
let MetricStub = null; // const newMetric = {
//   id: 1,
//   type: "memory",
//   value: "705",
//   uuid: "xxx",
//   createdAt: new Date(),
//   updatedAt: new Date()
// };

test.beforeEach(async () => {
  sandbox = sinon.createSandbox();
  MetricStub = {
    belongsTo: sinon.spy()
  }; // Model findAll Stub

  MetricStub.findAll = sandbox.stub();
  MetricStub.findAll.withArgs().returns(Promise.resolve(metricFixtures.all)); //Modell findByAgentUuid stub

  MetricStub.findByAgentUuid = sandbox.stub();
  MetricStub.findByAgentUuid.withArgs(findByAgentUuidArgs).returns(Promise.resolve(metricFixtures.findByAgentUuid(uuidArgs)));
  const setupDB = proxyquire("../", {
    "./models/agent": () => AgentStub,
    "./models/metric": () => MetricStub
  });
  db = await setupDB(config);
});
test.afterEach(() => {
  sinon.restore();
});
test("Metric", t => {
  t.truthy(db.Metric, "Metric service should exist");
});
test.serial("Metric#findByUuid", async t => {
  let metric = await db.Metric.findByAgentUuid(uuidArgs);
  t.deepEqual(metric, metricFixtures.findByAgentUuid(uuidArgs), "Should be the same."); //   t.true(MetricStub.findByAgentUuid.called, "FindByAgentUuid should be called");
});
//# sourceMappingURL=/Users/franndyabreu/Desktop/Platzi-Verse/platziverse-db/node_modules/.cache/ava/a49a7dc50f19a5385517633ef89b5547.js.map